# 객체

자바스크립트에는 여덟 개의 자료형이 있다.

그 중 일곱 개는 원시형이라 불리며 하나의 데이터(문자열, 숫자)만 담을 수 있다.

나머지 하나는 **객체**로서, 원시형과 달리 다양한 데이터를 담을 수 있다.

**키로 구분된 데이터 집합이나 복잡한 개체를 저장할 수 있다.**

---

## 객체를 만드는 방법 

객체는 **중괄호** `{…}`를 이용해 만들 수 있다.

중괄호 안에는 **'키(key): 값(value)'** 로 구성된 프로퍼티(property)를 여러 개 넣을 수 있다.

1. '객체 생성자' 문법
```
1 let person = new Object();
```
2. '객체 리터럴' 문법
```
1 let person = {}; // 주로 이 방법을 사용한다.
```

---

## 리터럴과 프로퍼티

**중괄호** `{…}` 안에는 **'키(key): 값(value)'** 으로 구성된 프로퍼티가 들어간다.
```
1 let person = {
2   name: "John",
3   age: 30
4 };
```
`콜론(:)`을 기준으로 왼쪽에는 **키**가, 오른쪽에는 **값**이 위치한다.

프로퍼티 키는 프로퍼티 **'이름'** 혹은 **'식별자'** 라고 부른다.

위 객체에는 프로퍼티가 두 개 있다.
1. "name"(키)와 "John"(값)
2. "age"(키)와 30(값)

---

점 표기법을 이용하면 프로퍼티 값을 **읽을 수 있다.**
```
// 예시
1 alert( user.name );
2 alert( user.age );
```

위와 같이 입력하면 각각 John과 30이라는 결과를 얻을 수 있다.

---

프로퍼티를 **추가**하거나 **삭제**할 수도 있다.

```
// 불린형 프로퍼티 추가
1 person.isAdmin = true;
```

```
// 프로퍼티 삭제
1 delete person.age;
```

---

만약 여러 단어를 조합하여 프로퍼티 이름을 만들고 싶다면 따옴표로 묶어줘야 한다.
```
let person = {
  name: "John",
  age: 30,
  "likes birds": true  // 복수의 단어는 따옴표로 묶어야 합니다.
};
```

또 마지막 프로퍼티 끝은 쉼표로 끝날 수 있다. 

```
let person = {
  name: "John",
  age: 30,
  "likes birds": true,  // 쉼표로 끝날 수 있음};
```
위와 같은 쉼표를 **‘trailing(길게 늘어지는)’ 혹은 ‘hanging(매달리는)’ 쉼표** 라고 부른다. 
끝에 쉼표를 붙이면 프로퍼티의 형태가 일관적이라 프로퍼티를 추가, 삭제, 이동하는 것이 쉬워진다.

---

## 대괄호 표기법 

여러 단어를 조합해 프로퍼티 키를 만든 경우엔, 점 표기법을 사용해 프로퍼티 값을 읽을 수 없다. 

**'점'은 키가 '유효한 변수 식별자'인 경우에만 사용할 수 있다.**

유효한 변수 식별자는,
1. 공백 사용 X
2. 숫자로 시작 X
3. `$`와 `_`를 제외한 특수 문자 X

만약 **키가 유효한 변수 식별자가 아닌 경우**에는 **'대괄호 표기법(square bracket notation)'** 을 사용할 수 있다.

---

```
1  let person = {};
2 
3  // set
4  person["likes birds"] = true;
5
6  // get
7  alert(person["likes birds"]); // true
8 
9  // delete
10 delete person["likes birds"];
```

대괄호 표기법 안에서 문자열을 사용할 땐,

문자열을 따옴표로 묶어주고 -> 대괄호를 표기하면 된다.

---

```
1 let key = "likes birds";
2
3 // person["likes birds"] = true; 와 같습니다.
4 person[key] = true;
```

변수 `key` 의 값이 어떤 이유에 의해서 변경될 수 있다. 계산이 끝난 후의 결과가 프로퍼티 키(객체 멤버변수명)으로 사용된다. 

```
// 예시
1 let person = {
2   name: "John",
3   age: 30
4 };
5
6 let key = prompt("사용자의 어떤 정보를 얻고 싶으신가요?", "name");
7
8 // 변수로 접근
9 alert( person[key] ); // John (프롬프트 창에 "name"을 입력한 경우)
```

---

이때 점 표기법은 사용할 수 없다.

```
1 let person = {
2   name: "John",
3   age: 30
4 };
5 
6 let key = "name";
7 alert( person.key ) // undefined
```
이때 7번 줄 `person.key` 의 의미는 
변수 key의 값("name")을 프로퍼티 키로 갖는 것을 의미하는 게 아니라 
**문자열 "key"라는 값 자체를 프로퍼티 키로 갖는 것을 의미**한다. 

---

### 계산된 프로퍼티 

**객체를 만들 때 객체 리터럴 안의 프로퍼티 키가 대괄호로 둘러싸여 있는 경우**를 계산된 프로퍼티라고 부른다. 
```
1 let fruit = prompt("어떤 과일을 구매하시겠습니까?", "apple");
2
3 let bag = {
4   [fruit]: 5,
5 };
6
7 alert(bag.apple); // "apple"이 입력되었다면 5가 출력된다.
```
위 코드는 **[fruit]** 는 프로퍼티 이름을 **변수 fruit**에서 가져오겠다는 것을 의미한다.

사용자가 대화상자 창에 `apple`를 입력한다면 `bag`에는 {apple: 5}가 할당된다. 

---

```
1 let fruit = prompt("어떤 과일을 구매하시겠습니까?", "apple");
2 let bag = {};
3 
4 // 변수 fruit를 사용해 프로퍼티 이름을 만들었습니다.
5 bag[fruit] = 5;
```

위 코드는 계산된 프로퍼티를 사용했다. 

---

### 대괄호 안에는 복잡한 표현식이 올 수도 있다.

```
1 let fruit = "apple";
2 let bag = {
3   [fruit + "Computers"]: 5 
4 };
```

3번 줄은 `bag.appleComputers` 을 뜻한다.

이처럼 대괄호 표기법은 프로퍼티 이름과 값의 제약이 없기 때문에 **점 표기법보다 훨씬 강력**하다.

작성하기 번거롭다는 단점이 있긴 하다.

-> 프로퍼티 이름이 확정된 상황이고, 단순한 이름이라면 처음에는 점 표기법을 사용하다가,

뭔가 복잡한 상황이 발생했을 때 대괄호 표기법으로 바꾸는 경우도 많다.

---

## 단축 프로퍼티

실무에서는 프로퍼티 값을 기존 변수에서 받아와 사용하는 경우가 종종 있다.

```
// 예시
1  function makeUser(name, age) {
2    return {
3      name: name,
4      age: age,
5      // ...등등
6    };
7  }
8
9  let user = makeUser("John", 30);
10 alert(user.name); // John
```

위 코드의 프로퍼티들은 이름과 값이 변수의 이름과 동일하다. 

이렇게 변수를 사용하여 프로퍼티를 만드는 경우가 흔하다.

---

**프로퍼티 값 단축 구문(property value shorthand)** 을 사용하면 코드를 짧게 줄일 수 있다.

1. name:name 대신 name만 적어주어도 프로퍼티를 설정할 수 있다.
```
1 function makeUser(name, age) {
2   return {
3     name, // name: name 과 같음
4     age,  // age: age 와 같음
5     // ...
6   };
7 }
```

2. 한 객체에서 일반 프로퍼티와 단축 프로퍼티를 함께 사용하는 것도 가능하다.

```
1 let user = {
2   name,  // name: name 과 같음
3   age: 30
4 };
```

---

## 프로퍼티 이름의 제약사항

변수 이름에는 `for`, `let`, `return` 같은 예약어를 사용하면 안된다.
그러나 **객체 프로퍼티**에는 이러한 제약이 없다.

```
1 // 예약어를 키로 사용해도 괜찮습니다.
2 let obj = {
3   for: 1,
4   let: 2,
5   return: 3
6 };
7 alert( obj.for + obj.let + obj.return );  // 6
```

문자형, 심볼형 값도 프로퍼티 키가 될 수 있다. 

---

**문자형이나 심볼형에 속하지 않은 값은 문자열로 자동 형 변환된다.**

```
1 let obj = {
2   0: "test" // "0": "test"와 동일합니다.
3 };
4 
5 // 숫자 0은 문자열 "0"으로 변환되기 때문에 두 얼럿 창은 같은 프로퍼티에 접근합니다,
6 alert( obj["0"] ); // test
7 alert( obj[0] ); // test (동일한 프로퍼티)
```

---

객체 프로퍼티 키에 쓸 수 있는 문자열에는 제약이 없지만, 역사적인 이유 때문에 특별 대우를 받는 이름이 하나 있다.

**`__proto__`**

```
1 let obj = {};
2 obj.__proto__ = 5; // 숫자를 할당합니다.
3 alert(obj.__proto__); // [object Object] - 숫자를 할당했지만 값은 객체가 되었습니다. 의도한대로 동작하지 않네요.
```

원시값 `5`를 할당했는데 무시된 것을 확인할 수 있다.

---

## 'in' 연산자로 프로퍼티 존재 여부 확인하기

다른 언어와 다르게 자바스크립트 객체의 중요한 특징 중 하나는,
존재하지 않는 프로퍼티에 접근해도 에러가 발생하지 않고 **`undefined`를 반환**한다는 것이다. 

이러한 특징을 응용하여 프로퍼티 존재 여부를 확인하는 방법이 있다. 

1. `undefined`와 비교하기
```
1 let user = {};
2 
3 alert( user.noSuchProperty === undefined ); // true는 '프로퍼티가 존재하지 않음'을 의미합니다.
```

---

2. 연산자 `in` 사용하기 

`"key" in object`

```
1 let user = { name: "John", age: 30 };
2
3 alert( "age" in user ); // user.age가 존재하므로 true가 출력됩니다.
4 alert( "blabla" in user ); // user.blabla는 존재하지 않기 때문에 false가 출력됩니다.
```
**`in` 왼쪽에 반드시 프로퍼티 이름**이 와야 한다.

+ 만약 따옴표를 생략한다면?
```
1 let user = { age: 30 };
2
3 let key = "age";
4 alert( key in user ); // true, 변수 key에 저장된 값("age")을 사용해 프로퍼티 존재 여부를 확인합니다.
```
해당 변수에 저장된 실제 값으로 프로퍼티를 검사한다.

---

1. `undefined`와 비교하기

위 방법은 보통의 상황에서는 꽤 잘 동작하지만, 가끔은 동작에 실패할 때도 있다. 

2. 연산자 `in` 사용하기 

`undefined`와 비교하는 것이 동작하지 않을 때, 사용하면 프로퍼티 존재 여부를 제대로 판별할 수 있다.

```
// 프로퍼티는 존재하는데, 값에 undefined를 할당한 예시
1 let obj = {
2   test: undefined
3 };
4 
5 alert( obj.test ); // 값이 'undefined'이므로, 얼럿 창엔 undefined가 출력됩니다. 그런데 프로퍼티 test는 존재합니다.
6 
7 alert( "test" in obj ); // 'in'을 사용하면 프로퍼티 유무를 제대로 확인할 수 있습니다(true가 출력됨).
```
여기서 `undefined`는 변수는 정의되어 있으나 값이 할당되지 않은 경우에 쓰기 때문에 프로퍼티 값이 `undefined`인 경우는 흔치 않다. **값을 알 수 없거나 값이 비어있다는 것을 나타낼 때**는 주로 **`null`** 을 사용한다. 
`in` 연산자는 위 예시에서 어울리지 않는다.

---

## 'for...in' 반복문

`for ...in` 반복문을 사용하면 객체의 모든 키를 순회할 수 있다. 
`for(초기식; 조건식; 증감식;)` 반복문과는 다르다.

* 문법

```
1 for(key in object) {
2 // 각 프로퍼티 키(key)를 이용하여 본문(body)을 실행한다.
3 }
```

---

* 예시

```
1  let person = {
2    name: "John",
3    age: 30,
4    isAdmin: true
5  };
6 
7  for (let key in person) {
8    // 키
9    alert( key );  // name, age, isAdmin
10   // 키에 해당하는 값
11   alert( person[key] ); // John, 30, true
12 }
```

`for..in` 반복문에서도 `for(초기식; 조건식; 증감식)`문처럼 

**반복 변수(looping variable)를 선언(let key)** 했다.

반복 변수명은 자유롭게 정할 수 있다.

`for (let prop in obj)`같이 key 말고 다른 변수명을 사용할 수 있다.

---

### 객체 정렬 방식

* 프로퍼티엔 순서가 있을까?

* 반복문은 프로퍼티를 추가한 순서대로 실행될까? 

* 이 순서는 항상 동일할까?

객체는 '특병한 방식으로 정렬' 된다.

정수 프로퍼티는 자동으로 정렬되고, 

그 외의 프로퍼티는 객체에 추가한 순서 그대로 정렬된다. 

---

```
1  let codes = {
2    "49": "독일",
3    "41": "스위스",
4    "44": "영국",
5    // ..,
6    "1": "미국"
7  };
8  
9  for (let code in codes) {
10   alert(code); // 1, 41, 44, 49
11 }
```

위는 국가 번호가 담겨있는 객체이다. 주 사용자가 독일인이라고 가정했을 때, 국가 번호를 선택하는 화면에서 `49`가 맨 앞에 오도록 하는 게 좋을 것이다.

하지만, 코드를 실행해 보면 미국(1)이 첫번째로 출력된 뒤, 41, 44, 49 순서대로 출력된다.

이유는 키(국가 번호)가 정수이기 때문에, `1, 41, 44, 49` 순으로 프로퍼티가 자동 정렬되었기 때문이다.

---

```
1  let user = {
2    name: "John",
3    surname: "Smith"
4  };
5  user.age = 25; // 프로퍼티를 하나 추가합니다.
6 
7  // 정수 프로퍼티가 아닌 프로퍼티는 추가된 순서대로 나열됩니다.
8  for (let prop in user) {
9    alert( prop ); // name, surname, age
10 }
```
키가 정수가 아닌 경우에는 작성된 순서대로 프로퍼티가 나열된다.

---

* 독일 국가 번호인 `49`를 가장 위에 출력되도록 하려면 어떻게 해야 할까?

각 나라 번호 앞에 `+`를 붙여 정수가 아닌 것처럼 속임수를 쓰면 된다.

```
1  let codes = {
2    "+49": "독일",
3    "+41": "스위스",
4    "+44": "영국",
5    // ..,
6    "+1": "미국"
7  };
8
9  for (let code in codes) {
10   alert( +code ); // 49, 41, 44, 1
11 }
``` 

---
## const 객체

const로 선언된 객체는 수정될 수 있다.
```
1 const person = {
2   name: "John"
3 };
4 
5 person.name = "Pete";
6 
7 alert(person.name); // Pete
```
2번 줄에 name: "John"을 정의하고, 5번 줄에서 name을 재정의했다. 
위 코드를 실행했을 때 나오는 결과는 pete이다.
const는 값(name)은 고정하지만, 내용(John)은 고정하지 않기 때문이다.

---
